/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
https://github.com/scottTomaszewski/obsidian-tag-tactician
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TagTacticianPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// src/batch/EditTagsModal.ts
var import_obsidian2 = require("obsidian");

// src/batch/TagSuggest.ts
var import_obsidian = require("obsidian");
var TagSuggestBase = class extends import_obsidian.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.onTagSelected = null;
    this.inputEl = inputEl;
    this.inputEl.addEventListener("input", () => {
      if (this.onTagSelected) {
        this.onTagSelected(this.inputEl.value);
      }
    });
  }
  /**
   * Set a callback to be triggered when a tag is selected or input value changes
   */
  setTagSelectedCallback(callback) {
    this.onTagSelected = callback;
  }
  renderSuggestion(tag, el) {
    const div = el.createEl("div", { cls: "tag-autocomplete-item", text: tag });
  }
  selectSuggestion(tag) {
    var _a;
    const inputEl = this.inputEl;
    const currentValue = (_a = inputEl.value) != null ? _a : "";
    const currentTags = currentValue.split(/[, ]+/).filter((t) => t);
    if (currentTags.length > 0) {
      currentTags[currentTags.length - 1] = tag;
    } else {
      currentTags.push(tag);
    }
    inputEl.value = currentTags.join(", ") + ", ";
    const newCursorPosition = inputEl.value.length;
    inputEl.setSelectionRange(newCursorPosition, newCursorPosition);
    inputEl.trigger("input");
    if (this.onTagSelected) {
      this.onTagSelected(inputEl.value);
    }
    this.close();
  }
};
var ExistingTagSuggest = class extends TagSuggestBase {
  async getSuggestions(inputStr) {
    const allTags = this.getVaultTags();
    return this.filterTags(allTags, inputStr);
  }
  getVaultTags() {
    const allTags = /* @__PURE__ */ new Set();
    const mdFiles = this.app.vault.getMarkdownFiles();
    for (const file of mdFiles) {
      const frontmatter = this.app.metadataCache.getFileCache(file).frontmatter;
      let currentTags = (0, import_obsidian.parseFrontMatterTags)(frontmatter);
      currentTags = currentTags === null ? currentTags = [] : currentTags;
      currentTags.map((t) => t.startsWith("#") ? t.slice(1) : t).forEach((t) => allTags.add(t));
    }
    return Array.from(allTags).sort();
  }
  filterTags(tags, inputStr) {
    const currentTags = inputStr.split(/[, ]+/);
    const lastTag = currentTags[currentTags.length - 1].toLowerCase();
    if (lastTag.length === 0) {
      return [];
    }
    const filteredTags = tags.filter((tag) => tag.toLowerCase().includes(lastTag)).slice(0, 10);
    return filteredTags;
  }
};
var FileTagSuggest = class extends TagSuggestBase {
  constructor(app, inputEl, files) {
    super(app, inputEl);
    this.files = files;
  }
  async getSuggestions(inputStr) {
    const fileTags = this.getTagsFromFiles();
    return this.filterTags(fileTags, inputStr);
  }
  getTagsFromFiles() {
    const allTags = /* @__PURE__ */ new Set();
    const metadataCache = this.app.metadataCache;
    this.files.forEach((file) => {
      const frontmatter = this.app.metadataCache.getFileCache(file).frontmatter;
      let currentTags = (0, import_obsidian.parseFrontMatterTags)(frontmatter);
      currentTags = currentTags === null ? currentTags = [] : currentTags;
      currentTags.map((t) => t.startsWith("#") ? t.slice(1) : t).forEach((t) => allTags.add(t));
    });
    return Array.from(allTags).sort();
  }
  filterTags(tags, inputStr) {
    const currentTags = inputStr.split(/[, ]+/);
    const lastTag = currentTags[currentTags.length - 1].toLowerCase();
    if (lastTag.length === 0) {
      return [];
    }
    const filteredTags = tags.filter((tag) => tag.toLowerCase().includes(lastTag)).slice(0, 10);
    return filteredTags;
  }
};

// src/batch/EditTagsModal.ts
var EditTagsModal = class extends import_obsidian2.Modal {
  constructor(app, files, onSubmit) {
    super(app);
    // valid markdown files
    this.nonMarkdownFiles = [];
    this.invalidYamlFiles = [];
    // The user's add/remove arrays, extracted from text inputs
    this.tagsToAdd = [];
    this.tagsToRemove = [];
    // Holds each file's current + proposed tags, along with references to UI elements
    this.fileTagData = [];
    this.mdFiles = files.filter(
      (f) => f instanceof import_obsidian2.TFile && f.extension === "md"
    );
    this.nonMarkdownFiles = files.filter(
      (f) => !(f instanceof import_obsidian2.TFile && f.extension === "md")
    );
    this.onSubmit = onSubmit;
  }
  async onOpen() {
    const { contentEl } = this;
    this.modalEl.addClass("tt-bulk-tag-modal");
    contentEl.empty();
    contentEl.createEl("h2", { text: "Bulk edit frontmatter tags" });
    if (this.nonMarkdownFiles.length > 0) {
      contentEl.createEl("p", {
        text: `Warning: The following ${this.nonMarkdownFiles.length === 1 ? "item is" : "items are"} not Markdown files (won't be modified):`
      });
      const ul = contentEl.createEl("ul");
      this.nonMarkdownFiles.forEach((f) => {
        ul.createEl("li", { text: f.name });
      });
    }
    await this.loadFileTagData();
    if (this.invalidYamlFiles.length > 0) {
      contentEl.createEl("p", {
        cls: "warning",
        text: `The following file(s) have invalid or duplicate YAML keys (won't be modified):`
      });
      const ul = contentEl.createEl("ul");
      this.invalidYamlFiles.forEach((f) => {
        ul.createEl("li", { text: f.name });
      });
    }
    new import_obsidian2.Setting(contentEl).setName("Add Tags").setDesc("Tags to add to files, separated by commas.").addText((input) => {
      input.setPlaceholder("Tags to add (comma separated)").onChange(async (value) => {
        this.tagsToAdd = this.parseTagInput(value);
        this.updateProposedTags();
      });
      new ExistingTagSuggest(this.app, input.inputEl);
    });
    new import_obsidian2.Setting(contentEl).setName("Remove Tags").setDesc("Tags to remove from files, separated by commas.").addText((input) => {
      input.setPlaceholder("Tags to remove (comma separated)").onChange(async (value) => {
        this.tagsToRemove = this.parseTagInput(value);
        this.updateProposedTags();
      });
      new FileTagSuggest(this.app, input.inputEl, this.mdFiles);
    });
    new import_obsidian2.Setting(contentEl).setName("File selection").setDesc("Check or uncheck all files at once.").addButton(
      (btn) => btn.setButtonText("Select all").onClick(() => {
        for (const tagData of this.fileTagData) {
          tagData.accepted = true;
          if (tagData.checkboxEl) {
            tagData.checkboxEl.checked = true;
          }
        }
      })
    ).addButton(
      (btn) => btn.setButtonText("Deselect all").onClick(() => {
        for (const tagData of this.fileTagData) {
          tagData.accepted = false;
          if (tagData.checkboxEl) {
            tagData.checkboxEl.checked = false;
          }
        }
      })
    );
    const tableContainer = contentEl.createEl("div", {
      cls: "bulk-tag-table-container"
    });
    const headerRow = tableContainer.createEl("div", {
      cls: "bulk-tag-table-row table-header-row"
    });
    headerRow.createEl("span", { cls: "cb-col" });
    headerRow.createEl("span", {
      text: "File name",
      cls: "file-name-col header-col"
    });
    headerRow.createEl("span", {
      text: "Current tags",
      cls: "current-tags-col header-col"
    });
    headerRow.createEl("span", {
      text: "Proposed tags",
      cls: "proposed-tags-col header-col"
    });
    for (const tagData of this.fileTagData) {
      this.renderFileRow(tableContainer, tagData);
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.createEl("button", {
      text: "Apply Changes",
      cls: "mod-cta"
    }).addEventListener("click", () => this.applyChanges());
    buttonContainer.createEl("button", {
      text: "Cancel"
    }).addEventListener("click", () => this.close());
  }
  onClose() {
    this.contentEl.empty();
  }
  /**
   * Loads frontmatter from each MD file. If YAML is invalid, we skip that file.
   */
  async loadFileTagData() {
    this.fileTagData = [];
    this.invalidYamlFiles = [];
    for (const file of this.mdFiles) {
      const frontmatter = this.app.metadataCache.getFileCache(file).frontmatter;
      let currentTags = (0, import_obsidian2.parseFrontMatterTags)(frontmatter);
      currentTags = currentTags === null ? currentTags = [] : currentTags;
      currentTags = currentTags.map((t) => t.startsWith("#") ? t.slice(1) : t);
      const proposedTags = [...currentTags].sort();
      this.fileTagData.push({
        file,
        currentTags,
        proposedTags,
        accepted: true
      });
    }
  }
  /**
   * Renders a single "row" for the given file's data, storing references to the
   * checkbox and proposed tags elements directly in the tagData object.
   */
  renderFileRow(containerEl, tagData) {
    const rowEl = containerEl.createEl("div", { cls: "bulk-tag-table-row" });
    const cbContainer = rowEl.createEl("div", { cls: "cb-col" });
    const checkbox = cbContainer.createEl("input", { type: "checkbox" });
    checkbox.checked = tagData.accepted;
    checkbox.onchange = () => {
      tagData.accepted = checkbox.checked;
    };
    tagData.checkboxEl = checkbox;
    rowEl.createEl("span", {
      text: tagData.file.name,
      cls: "file-name-col"
    });
    const currTags = rowEl.createEl("span", { cls: "current-tags-col" });
    tagData.currentTags.forEach((t) => currTags.createEl("a", { cls: "tag", text: t, attr: { disabled: true } }));
    const propTags = rowEl.createEl("span", { cls: "proposed-tags-col" });
    tagData.proposedTags.forEach((t) => propTags.createEl("a", { cls: "tag", text: t, attr: { disabled: true } }));
    tagData.proposedEl = propTags;
  }
  /**
   * Recalculates the proposedTags for each file after user modifies
   * "tags to add" or "tags to remove." Also updates the UI text.
   */
  updateProposedTags() {
    for (const tagData of this.fileTagData) {
      let newTagSet = [...tagData.currentTags];
      for (const tag of this.tagsToAdd) {
        if (!newTagSet.includes(tag)) {
          newTagSet.push(tag);
        }
      }
      newTagSet = newTagSet.filter((t) => !this.tagsToRemove.includes(t));
      newTagSet.sort();
      tagData.proposedTags = newTagSet;
      if (tagData.proposedEl !== void 0) {
        tagData.proposedEl.empty();
        newTagSet.forEach((t) => {
          var _a;
          (_a = tagData.proposedEl) == null ? void 0 : _a.createEl("a", {
            cls: "tag",
            text: t,
            attr: { disabled: true }
          });
        });
      }
    }
  }
  applyChanges() {
    const updates = this.fileTagData.filter((td) => td.accepted).map((td) => ({
      file: td.file,
      finalTags: td.proposedTags
    }));
    if (updates.length === 0) {
      new import_obsidian2.Notice("No files selected for update.");
      this.close();
      return;
    }
    this.close();
    this.onSubmit(updates);
  }
  parseTagInput(input) {
    return input.split(/[,\s]+/).filter((tag) => tag.trim().length > 0).map((tag) => tag.trim());
  }
};

// src/batch/FileTagProcessor.ts
var import_obsidian3 = require("obsidian");

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// src/batch/FileTagProcessor.ts
async function applyTagUpdates(app, updates, settings) {
  let modifiedCount = 0;
  for (const { file, finalTags } of updates) {
    if (file.extension !== "md")
      continue;
    await app.vault.process(file, (oldContent) => {
      const frontMatterInfo = (0, import_obsidian3.getFrontMatterInfo)(oldContent);
      let newContent;
      if (frontMatterInfo.exists) {
        const fmData = (0, import_obsidian3.parseYaml)(frontMatterInfo.frontmatter);
        fmData.tags = finalTags.length > 0 ? finalTags : void 0;
        const newYaml = dumpYaml(fmData, settings.tagListStyle);
        newContent = oldContent.slice(0, frontMatterInfo.from) + `${newYaml}
` + oldContent.slice(frontMatterInfo.to);
      } else {
        if (finalTags.length === 0) {
          return oldContent;
        }
        const fmData = { tags: finalTags.length > 0 ? finalTags : void 0 };
        const newYaml = dumpYaml(fmData, settings.tagListStyle);
        newContent = `---
${newYaml}
---
${oldContent}`;
      }
      if (!newContent || newContent === oldContent) {
        return oldContent;
      }
      modifiedCount++;
      return newContent;
    });
  }
  return modifiedCount;
}
function dumpYaml(fmData, style) {
  if (style === "brackets") {
    return dump(fmData, { flowLevel: 1 }).trim();
  } else {
    return dump(fmData, { flowLevel: -1 }).trim();
  }
}

// src/settings/TagTacticianSettingTab.ts
var import_obsidian5 = require("obsidian");

// src/settings/IconSelectionModal.ts
var import_obsidian4 = require("obsidian");
var IconSelectionModal = class extends import_obsidian4.Modal {
  constructor(app, currentIcon, onSelect) {
    super(app);
    this.currentIcon = currentIcon;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select an Icon" });
    contentEl.createEl("button", { text: "No Icon" }).addEventListener("click", () => {
      this.onSelect("");
      this.close();
    });
    const iconList = this.getAvailableIcons();
    const iconGrid = contentEl.createDiv({ cls: "icon-grid" });
    iconList.forEach((iconName) => {
      const iconButton = iconGrid.createEl("button", { cls: "icon-button" });
      iconButton.setAttr("aria-label", iconName);
      const iconEl = iconButton.createDiv({ cls: "icon" });
      (0, import_obsidian4.setIcon)(iconEl, iconName);
      iconButton.addEventListener("click", () => {
        this.onSelect(iconName);
        this.close();
      });
    });
    const style = document.createElement("style");
    style.textContent = `
      .icon-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
        gap: 10px;
        margin-top: 20px;
      }
      .icon-button {
        background: none;
        border: none;
        padding: 10px;
        cursor: pointer;
      }
      .icon-button:hover {
        background-color: var(--background-modifier-hover);
      }
      .icon {
        width: 24px;
        height: 24px;
        margin: 0 auto;
      }
    `;
    contentEl.appendChild(style);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  getAvailableIcons() {
    return (0, import_obsidian4.getIconIds)().filter((id) => id.startsWith("lucide-")).map((id) => id.slice(7));
  }
};

// src/settings/TagTacticianSettingTab.ts
var TagTacticianSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian5.Setting(containerEl).setName("Bulk tag operations").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Show warning for non-markdown files").setDesc("If enabled, the modal will display a warning for non-markdown files.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showNonMarkdownWarning).onChange(async (val) => {
        this.plugin.settings.showNonMarkdownWarning = val;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Tag list style").setDesc("Choose how frontmatter tags are serialized: hyphen block style or bracket inline style.").addDropdown((dropdown) => {
      dropdown.addOption("hyphens", "Hyphens (block style)").addOption("brackets", "Square brackets (inline style)").setValue(this.plugin.settings.tagListStyle).onChange(async (value) => {
        this.plugin.settings.tagListStyle = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Related notes view").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Show tags by default").setDesc("If enabled, the Related Notes sidebar will initially show tags.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.defaultShowTags).onChange(async (val) => {
        this.plugin.settings.defaultShowTags = val;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Show score by default").setDesc("If enabled, the Related Notes sidebar will initially show note scores.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.defaultShowScore).onChange(async (val) => {
        this.plugin.settings.defaultShowScore = val;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Hide results with score below").setDesc("Hide notes in the Related Notes sidebar with a score below this threshold.").addText((text) => {
      text.setPlaceholder("1").setValue(this.plugin.settings.minimumRelatedNotesScore.toString()).onChange(async (val) => {
        this.plugin.settings.minimumRelatedNotesScore = Number(val);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Related notes score weighting").setHeading();
    containerEl.createEl("p", { text: "Higher values increase importance." });
    new import_obsidian5.Setting(containerEl).setName("Tag similarity weight").setDesc("The weight of tag similarity in the Related Notes score.").addText((text) => {
      text.setPlaceholder("1.0").setValue(this.plugin.settings.weightTagSimilarity.toString()).onChange(async (val) => {
        this.plugin.settings.weightTagSimilarity = Number(val);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Title similarity weight").setDesc("The weight of file name similarity in the Related Notes score.").addText((text) => {
      text.setPlaceholder("1.0").setValue(this.plugin.settings.weightTitleSimilarity.toString()).onChange(async (val) => {
        this.plugin.settings.weightTitleSimilarity = Number(val);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Path similarity weight").setDesc("The weight of file path similarity in the Related Notes score.").addText((text) => {
      text.setPlaceholder("1.0").setValue(this.plugin.settings.weightPathSimilarity.toString()).onChange(async (val) => {
        this.plugin.settings.weightPathSimilarity = Number(val);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Link interconnections weight").setDesc("The weight of notes having links to each other in the Related Notes score.").addText((text) => {
      text.setPlaceholder("1.0").setValue(this.plugin.settings.weightLinkInterconnections.toString()).onChange(async (val) => {
        this.plugin.settings.weightLinkInterconnections = Number(val);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Tag navigation view").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Default navigation sorting").setDesc("Choose how tags and notes should be sorted.").addDropdown((dropdown) => {
      dropdown.addOption("alphabetically-descending", "Alphabetically").addOption("file-count-descending", "By note count").addOption("created-time-descending", "Newest notes first").addOption("created-time-ascending", "Oldest notes first").addOption("modified-time-descending", "Recently modified first").addOption("modified-time-ascending", "Least recently modified first").setValue(this.plugin.settings.nbtDefaultSort).onChange(async (value) => {
        this.plugin.settings.nbtDefaultSort = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Tag Group Icon (closed)").setDesc("Select the icon used for a collapsed tag group (default: 'chevron-right')").addButton(
      (btn) => {
        if (this.plugin.settings.nbtTagGroupClosedIcon) {
          btn.setIcon(this.plugin.settings.nbtTagGroupClosedIcon);
        } else {
          btn.setButtonText("Icon...");
        }
        return btn.onClick(() => {
          new IconSelectionModal(
            this.app,
            this.plugin.settings.nbtTagGroupClosedIcon,
            async (selectedIcon) => {
              if (selectedIcon !== "") {
                this.plugin.settings.nbtTagGroupClosedIcon = selectedIcon;
                btn.setIcon(selectedIcon);
              } else {
                this.plugin.settings.nbtTagGroupClosedIcon = void 0;
                btn.setButtonText("Icon...");
              }
              await this.plugin.saveSettings();
            }
          ).open();
        });
      }
    );
    new import_obsidian5.Setting(containerEl).setName("Tag Group Icon (open)").setDesc("Select the icon used for an expanded tag group (default: 'chevron-down')").addButton(
      (btn) => {
        if (this.plugin.settings.nbtTagGroupOpenIcon) {
          btn.setIcon(this.plugin.settings.nbtTagGroupOpenIcon);
        } else {
          btn.setButtonText("Icon...");
        }
        return btn.onClick(() => {
          new IconSelectionModal(
            this.app,
            this.plugin.settings.nbtTagGroupOpenIcon,
            async (selectedIcon) => {
              if (selectedIcon !== "") {
                this.plugin.settings.nbtTagGroupOpenIcon = selectedIcon;
                btn.setIcon(selectedIcon);
              } else {
                this.plugin.settings.nbtTagGroupOpenIcon = void 0;
                btn.setButtonText("Icon...");
              }
              await this.plugin.saveSettings();
            }
          ).open();
        });
      }
    );
    new import_obsidian5.Setting(containerEl).setName("File Icon").setDesc("Select the icon used for a file (default: '')").addButton(
      (btn) => {
        if (this.plugin.settings.nbtFileIcon) {
          btn.setIcon(this.plugin.settings.nbtFileIcon);
        } else {
          btn.setButtonText("Icon...");
        }
        return btn.onClick(() => {
          new IconSelectionModal(
            this.app,
            this.plugin.settings.nbtFileIcon,
            async (selectedIcon) => {
              if (selectedIcon !== "") {
                this.plugin.settings.nbtFileIcon = selectedIcon;
                btn.setIcon(selectedIcon);
              } else {
                this.plugin.settings.nbtFileIcon = void 0;
                btn.setButtonText("Icon...");
              }
              await this.plugin.saveSettings();
            }
          ).open();
        });
      }
    );
  }
};

// src/settings/PluginSettings.ts
var DEFAULT_SETTINGS = {
  showNonMarkdownWarning: true,
  tagListStyle: "hyphens",
  defaultShowTags: true,
  defaultShowScore: true,
  minimumRelatedNotesScore: 1,
  weightTagSimilarity: 1,
  weightTitleSimilarity: 1,
  weightPathSimilarity: 1,
  weightLinkInterconnections: 1,
  nbtDefaultSort: "alphabetically-descending",
  nbtTagGroupClosedIcon: "chevron-right",
  nbtTagGroupOpenIcon: "chevron-down",
  nbtFileIcon: ""
};

// src/relatedView/TagIndexer.ts
var import_obsidian6 = require("obsidian");
var TagIndexer = class {
  constructor(plugin) {
    this.noteTagsMap = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  /**
   * Build a simple in-memory map for titles & tags of each note.
   * (Optional, if you want to skip repeated metadata lookups.)
   */
  async buildIndex() {
    const allFiles = this.plugin.app.vault.getMarkdownFiles();
    this.noteTagsMap.clear();
    for (const file of allFiles) {
      await this.indexSingleFile(file);
    }
    console.log(`[TagIndexer] Indexed ${allFiles.length} files.`);
  }
  async indexSingleFile(file) {
    const notePath = file.path;
    const cache = this.plugin.app.metadataCache.getFileCache(file);
    if (!cache) {
      return;
    }
    const tags = /* @__PURE__ */ new Set();
    if (cache.tags) {
      for (const t of cache.tags) {
        let rawTag = t.tag;
        if (rawTag.startsWith("#"))
          rawTag = rawTag.substring(1);
        tags.add(rawTag);
      }
    }
    if (cache.frontmatter && cache.frontmatter.tags) {
      const fmTags = cache.frontmatter.tags;
      if (Array.isArray(fmTags)) {
        fmTags.forEach((tag) => typeof tag === "string" && tags.add(tag));
      } else if (typeof fmTags === "string") {
        fmTags.split(/[, ]+/).forEach((t) => t && tags.add(t));
      }
    }
    this.noteTagsMap.set(notePath, tags);
  }
  /**
   * Approach #2:
   * - Read the current note's metadata directly
   * - Expand tags into prefix segments
   * - Iterate *all* notes in the vault (except self)
   * - For each, gather prefix segments, compute overlap + title similarity
   */
  computeRelatedNotes(currentNotePath) {
    var _a, _b;
    const file = this.plugin.app.vault.getAbstractFileByPath(currentNotePath);
    if (!(file instanceof import_obsidian6.TFile))
      return [];
    const currCache = this.plugin.app.metadataCache.getFileCache(file);
    if (!currCache)
      return [];
    const currFullTags = gatherTagsFromCache(currCache);
    const currentNoteSegments = gatherAllPrefixSegmentsForNote(currFullTags);
    const currentTitle = file.basename.toLowerCase();
    const allFiles = this.plugin.app.vault.getMarkdownFiles();
    const results = [];
    const weightTagSimilarity = this.plugin.settings.weightTagSimilarity;
    const weightTitleSimilarity = this.plugin.settings.weightTitleSimilarity;
    const weightPathSimilarity = this.plugin.settings.weightPathSimilarity;
    const weightLinkInterconnections = this.plugin.settings.weightLinkInterconnections;
    for (const candidateFile of allFiles) {
      const candidatePath = candidateFile.path;
      if (candidatePath === currentNotePath) {
        continue;
      }
      const candCache = this.plugin.app.metadataCache.getFileCache(candidateFile);
      if (!candCache)
        continue;
      const candTags = gatherTagsFromCache(candCache);
      const candidateSegments = gatherAllPrefixSegmentsForNote(candTags);
      let prefixOverlapScore = 0;
      for (const seg of candidateSegments) {
        if (currentNoteSegments.has(seg)) {
          prefixOverlapScore += 1;
        }
      }
      const candidateTitle = candidateFile.basename.toLowerCase();
      const titleSimScore = levenshteinSimilarity(currentTitle, candidateTitle);
      let pathSimScore = 0;
      if (candidateFile.parent.path !== "/" && file.parent.path !== "/") {
        pathSimScore = levenshteinSimilarity(file.path, candidatePath);
      }
      let linkScore = 0;
      if ((_a = candCache.links) == null ? void 0 : _a.map((l) => l.link).includes(file.basename)) {
        linkScore++;
      }
      if ((_b = currCache.links) == null ? void 0 : _b.map((l) => l.link).includes(candidateFile.basename)) {
        linkScore++;
      }
      const totalScore = 0 + weightTagSimilarity * prefixOverlapScore + weightTitleSimilarity * titleSimScore + weightPathSimilarity * pathSimScore + weightLinkInterconnections * linkScore;
      if (totalScore > 0) {
        results.push({ notePath: candidatePath, score: totalScore });
      }
    }
    results.sort((a, b) => b.score - a.score);
    return results;
  }
  /**
   * Accessor if you need the tags for a note from the in-memory map (like in your view).
   */
  getNoteTags(notePath) {
    var _a;
    return (_a = this.noteTagsMap.get(notePath)) != null ? _a : /* @__PURE__ */ new Set();
  }
};
function gatherTagsFromCache(cache) {
  const tags = /* @__PURE__ */ new Set();
  if (cache.tags) {
    for (const t of cache.tags) {
      let rawTag = t.tag;
      if (rawTag.startsWith("#"))
        rawTag = rawTag.substring(1);
      tags.add(rawTag);
    }
  }
  if (cache.frontmatter && cache.frontmatter.tags) {
    const fmTags = cache.frontmatter.tags;
    if (Array.isArray(fmTags)) {
      fmTags.forEach((tag) => typeof tag === "string" && tags.add(tag));
    } else if (typeof fmTags === "string") {
      fmTags.split(/[, ]+/).forEach((t) => t && tags.add(t));
    }
  }
  return tags;
}
function expandTagIntoPrefixes(fullTag) {
  const segments = fullTag.split("/");
  const prefixes = [];
  for (let i = 1; i <= segments.length; i++) {
    prefixes.push(segments.slice(0, i).join("/"));
  }
  return prefixes;
}
function gatherAllPrefixSegmentsForNote(noteTags) {
  const allSegments = /* @__PURE__ */ new Set();
  for (const tag of noteTags) {
    for (const prefix of expandTagIntoPrefixes(tag)) {
      allSegments.add(prefix);
    }
  }
  return allSegments;
}
function levenshteinDistance(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = [];
  for (let i = 0; i <= m; i++) {
    dp[i] = [i];
  }
  for (let j = 0; j <= n; j++) {
    dp[0][j] = j;
  }
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(
        dp[i - 1][j] + 1,
        // deletion
        dp[i][j - 1] + 1,
        // insertion
        dp[i - 1][j - 1] + cost
        // substitution
      );
    }
  }
  return dp[m][n];
}
function levenshteinSimilarity(s1, s2) {
  var longer = s1;
  var shorter = s2;
  if (s1.length < s2.length) {
    longer = s2;
    shorter = s1;
  }
  var longerLength = longer.length;
  if (longerLength == 0) {
    return 1;
  }
  return (longerLength - levenshteinDistance(longer, shorter)) / parseFloat(longerLength);
}

// src/relatedView/RelatedNotesView.ts
var import_obsidian7 = require("obsidian");
var RELATED_NOTES_VIEW_TYPE = "related-notes-view";
var RelatedNotesView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    /** User-entered filter text for live filtering notes. */
    this.filterQuery = "";
    this.plugin = plugin;
    this.showTags = this.plugin.settings.defaultShowTags;
    this.showScore = this.plugin.settings.defaultShowScore;
  }
  getViewType() {
    return RELATED_NOTES_VIEW_TYPE;
  }
  getDisplayText() {
    return "Related Notes";
  }
  getIcon() {
    return "git-compare";
  }
  async onOpen() {
    this.refresh();
  }
  async onClose() {
  }
  /**
   * Rebuilds the entire sidebar content, including controls and the note list.
   */
  refresh() {
    this.showTags = this.plugin.settings.defaultShowTags;
    this.showScore = this.plugin.settings.defaultShowScore;
    const container = this.containerEl;
    container.addClass("related-notes-container");
    container.empty();
    const header = container.createEl("div", { cls: "related-notes-header" });
    const titleRow = header.createEl("div", { cls: "related-notes-title-row" });
    titleRow.createEl("h4", { text: "Related Notes" });
    const optionsBtn = titleRow.createEl("button", { cls: "clickable-icon" });
    (0, import_obsidian7.setIcon)(optionsBtn, "gear");
    optionsBtn.style.marginLeft = "1rem";
    optionsBtn.onclick = (evt) => {
      const menu = new import_obsidian7.Menu(this.app);
      menu.addItem((item) => {
        item.setTitle((this.showTags ? "\u2713 " : "") + "Show Tags").onClick(() => {
          this.showTags = !this.showTags;
          this.refreshList();
        });
      });
      menu.addItem((item) => {
        item.setTitle((this.showScore ? "\u2713 " : "") + "Show Score").onClick(() => {
          this.showScore = !this.showScore;
          this.refreshList();
        });
      });
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("Refresh Notes").onClick(() => {
          this.refreshList();
        });
      });
      menu.showAtMouseEvent(evt);
    };
    const controls = header.createEl("div", { cls: "related-notes-controls" });
    const filterWrapper = controls.createEl("div", { cls: "filter-input-container" });
    const filterInput = filterWrapper.createEl("input", {
      type: "search",
      placeholder: "Filter by name or tag...",
      cls: "filter-input"
    });
    filterInput.value = this.filterQuery;
    const clearButton = filterWrapper.createEl("span", {
      cls: "search-input-clear-button",
      attr: {
        "aria-label": "Clear filter"
      }
    });
    clearButton.style.display = this.filterQuery ? "flex" : "none";
    filterInput.oninput = () => {
      this.filterQuery = filterInput.value.trim().toLowerCase();
      clearButton.style.display = this.filterQuery ? "flex" : "none";
      this.refreshList();
    };
    clearButton.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      filterInput.value = "";
      this.filterQuery = "";
      clearButton.style.display = "none";
      this.refreshList();
      filterInput.focus();
    };
    const listContainer = container.createEl("div", { cls: "related-notes-list-container" });
    this.renderNoteList(listContainer);
  }
  /**
   * Rerender just the note list portion, preserving the top controls.
   */
  refreshList() {
    const listContainer = this.containerEl.querySelector(".related-notes-list-container");
    if (listContainer) {
      listContainer.empty();
      this.renderNoteList(listContainer);
    }
  }
  /**
   * Actually render the note items into the given container,
   * applying any filters and toggles.
   */
  renderNoteList(container) {
    var _a, _b;
    const results = this.plugin.computeRelatedNotes();
    if (!results.length) {
      container.createEl("p", { text: "No related notes found." });
      return;
    }
    const filteredResults = this.applyFilter(results);
    if (!filteredResults.length) {
      container.createEl("p", { text: "No notes match your filter." });
      return;
    }
    const topResults = filteredResults.filter((r) => r.score >= this.plugin.settings.minimumRelatedNotesScore);
    for (const { notePath, score } of topResults) {
      const noteFile = this.app.vault.getAbstractFileByPath(notePath);
      const item = container.createEl("div", { cls: "related-note-item" });
      const itemContent = item.createEl("div", { cls: "related-note-item-content" });
      const titleRow = itemContent.createEl("div", { cls: "related-note-title-row" });
      const noteTitle = notePath.split(/[\\/]/).pop();
      const link = titleRow.createEl("a", { cls: "related-note-link" });
      link.innerHTML = this.highlightMatches(noteTitle, this.filterQuery);
      if (this.showScore) {
        const scoreEl = titleRow.createEl("span", { cls: "related-note-score" });
        scoreEl.setText(`${score.toPrecision(2)}`);
        if (noteFile instanceof import_obsidian7.TFile) {
          const currentFile = this.app.workspace.getActiveFile();
          if (currentFile) {
            const currFullTags = gatherTagsFromCache(this.app.metadataCache.getFileCache(currentFile));
            const currSegments = gatherAllPrefixSegmentsForNote(currFullTags);
            const candTags = gatherTagsFromCache(this.app.metadataCache.getFileCache(noteFile));
            const candSegments = gatherAllPrefixSegmentsForNote(candTags);
            let prefixOverlapScore = 0;
            const overlappingTags = [];
            for (const seg of candSegments) {
              if (currSegments.has(seg)) {
                prefixOverlapScore += 1;
                overlappingTags.push(seg);
              }
            }
            const currentTitle = currentFile.basename.toLowerCase();
            const candidateTitle = noteFile.basename.toLowerCase();
            const titleSimScore = levenshteinSimilarity(currentTitle, candidateTitle);
            let pathSimScore = 0;
            if (noteFile.parent.path !== "/" && currentFile.parent.path !== "/") {
              pathSimScore = levenshteinSimilarity(currentFile.path, notePath);
            }
            let linkScore = 0;
            const candCache = this.app.metadataCache.getFileCache(noteFile);
            const currCache = this.app.metadataCache.getFileCache(currentFile);
            if (candCache && currCache) {
              if ((_a = candCache.links) == null ? void 0 : _a.map((l) => l.link).includes(currentFile.basename)) {
                linkScore++;
              }
              if ((_b = currCache.links) == null ? void 0 : _b.map((l) => l.link).includes(noteFile.basename)) {
                linkScore++;
              }
            }
            const tagWeight = this.plugin.settings.weightTagSimilarity;
            const titleWeight = this.plugin.settings.weightTitleSimilarity;
            const pathWeight = this.plugin.settings.weightPathSimilarity;
            const linkWeight = this.plugin.settings.weightLinkInterconnections;
            const weightedTagScore = tagWeight * prefixOverlapScore;
            const weightedTitleScore = titleWeight * titleSimScore;
            const weightedPathScore = pathWeight * pathSimScore;
            const weightedLinkScore = linkWeight * linkScore;
            let tooltipText = "Score Breakdown:\n";
            tooltipText += `\u2022 Tag similarity: ${weightedTagScore.toFixed(2)} (${prefixOverlapScore} tag overlaps \xD7 ${tagWeight} weight)
`;
            if (overlappingTags.length > 0) {
              tooltipText += `  Overlapping tags: ${overlappingTags.join(", ")}
`;
            }
            tooltipText += `\u2022 Title similarity: ${weightedTitleScore.toFixed(2)} (${titleSimScore.toFixed(2)} similarity \xD7 ${titleWeight} weight)
`;
            tooltipText += `\u2022 Path similarity: ${weightedPathScore.toFixed(2)} (${pathSimScore.toFixed(2)} similarity \xD7 ${pathWeight} weight)
`;
            tooltipText += `\u2022 Link interconnections: ${weightedLinkScore.toFixed(2)} (${linkScore} links \xD7 ${linkWeight} weight)
`;
            tooltipText += `
Total score: ${score.toPrecision(3)}`;
            scoreEl.title = tooltipText;
          } else {
            scoreEl.title = "Score: " + score;
          }
        } else {
          scoreEl.title = "Score: " + score;
        }
      }
      link.title = notePath;
      link.addEventListener("mouseover", (event) => {
        this.app.workspace.trigger("hover-link", {
          event,
          linktext: this.app.vault.getAbstractFileByPath(notePath).path,
          sourcePath: link.pathname,
          source: RELATED_NOTES_VIEW_TYPE,
          targetEl: link,
          hoverParent: itemContent
        });
      });
      link.addEventListener("click", (evt) => {
        if (evt.button !== 0)
          return;
        evt.preventDefault();
        evt.stopPropagation();
        if (noteFile instanceof import_obsidian7.TFile) {
          this.app.workspace.getLeaf().openFile(noteFile);
        } else {
          console.error(`noteFile at ${notePath} is not a TFile?`);
        }
      });
      link.addEventListener("auxclick", (evt) => {
        if (evt.button !== 0)
          return;
        evt.preventDefault();
        evt.stopPropagation();
        if (noteFile instanceof import_obsidian7.TFile) {
          this.app.workspace.openLinkText(notePath, "", true, { active: false, eState: { focus: false } });
        }
      });
      link.addEventListener("contextmenu", (evt) => {
        evt.preventDefault();
        evt.stopPropagation();
        const menu = new import_obsidian7.Menu();
        this.plugin.app.workspace.trigger("file-menu", menu, noteFile, this.plugin.app.workspace.getLeaf());
        menu.showAtMouseEvent(evt);
      });
      if (this.showTags) {
        const noteTags = gatherTagsFromCache(this.app.metadataCache.getFileCache(noteFile));
        if (noteTags.size > 0) {
          const tagLine = itemContent.createEl("div", { cls: "related-note-tags" });
          noteTags.forEach((tagString) => {
            const tagA = tagLine.createEl("a", {
              cls: "tag",
              attr: { disabled: true }
            });
            tagA.innerHTML = this.highlightMatches(tagString, this.filterQuery);
          });
        }
      }
    }
  }
  /**
   * Returns a filtered subset of the raw results, based on `this.filterQuery`,
   * matching either the note title or any of its tags.
   */
  applyFilter(results) {
    if (!this.filterQuery)
      return results;
    const filter = this.filterQuery;
    const output = [];
    for (const item of results) {
      const notePath = item.notePath;
      const title = notePath;
      const noteTags = this.plugin.tagIndexer.getNoteTags(notePath);
      const lowerTitle = title.toLowerCase();
      if (lowerTitle.includes(filter)) {
        output.push(item);
        continue;
      }
      const hasTagMatch = Array.from(noteTags).some(
        (t) => t.toLowerCase().includes(filter)
      );
      if (hasTagMatch) {
        output.push(item);
      }
    }
    return output;
  }
  /**
   * Utility function that highlights all instances of `filter`
   * inside `text`, wrapping them in <mark>...</mark> (case-insensitive).
   */
  highlightMatches(text, filter) {
    if (!filter)
      return text;
    const re = new RegExp(`(${this.escapeRegex(filter)})`, "gi");
    return text.replace(re, "<span class='highlight'>$1</span>");
  }
  /**
   * Escape special regex characters in the filter string.
   * e.g. if filter is "foo?", we want to match literal "?",
   * not a wildcard.
   */
  escapeRegex(str2) {
    return str2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};

// src/navByTag/NavByTagView.ts
var import_obsidian9 = require("obsidian");

// src/navByTag/TagNavigationRenderer.ts
var import_obsidian8 = require("obsidian");
var TagNavigationRenderer = class {
  // Default to tags and files
  /**
   * Create a new tag navigation renderer
   */
  constructor(plugin, sortMode) {
    this.filterQuery = "";
    this.expandAll = false;
    this.filterMode = "tags-and-files" /* TagsAndFiles */;
    this.plugin = plugin;
    this.sortMode = sortMode;
  }
  /**
   * Get the current sort mode
   */
  getSortMode() {
    return this.sortMode;
  }
  /**
   * Set filter query for searching
   */
  setFilterQuery(query) {
    this.filterQuery = query;
  }
  /**
   * Get current filter query
   */
  getFilterQuery() {
    return this.filterQuery;
  }
  /**
   * Set expand all setting
   */
  setExpandAll(expand) {
    this.expandAll = expand;
  }
  /**
   * Get expand all setting
   */
  getExpandAll() {
    return this.expandAll;
  }
  /**
   * Set the current filter mode
   */
  setFilterMode(mode) {
    this.filterMode = mode;
  }
  /**
   * Get the current filter mode
   */
  getFilterMode() {
    return this.filterMode;
  }
  /**
   * Render the sort button with current mode
   */
  renderSortButton(buttonEl) {
    buttonEl.empty();
    let sortIcon;
    switch (this.sortMode) {
      case "alphabetically-descending":
        sortIcon = "arrow-down-az";
        buttonEl.setAttribute("aria-label", "Sort alphabetically (A-Z)");
        buttonEl.title = "Current sort: Alphabetical (A-Z)\nClick to change sort method";
        break;
      case "file-count-descending":
        sortIcon = "arrow-down-10";
        buttonEl.setAttribute("aria-label", "Sort by note count (descending)");
        buttonEl.title = "Current sort: By note count (highest first)\nClick to change sort method";
        break;
      case "created-time-descending":
        sortIcon = "calendar-plus";
        buttonEl.setAttribute("aria-label", "Sort by creation date (newest first)");
        buttonEl.title = "Current sort: By creation date (newest first)\nClick to change sort method";
        break;
      case "created-time-ascending":
        sortIcon = "calendar-minus";
        buttonEl.setAttribute("aria-label", "Sort by creation date (oldest first)");
        buttonEl.title = "Current sort: By creation date (oldest first)\nClick to change sort method";
        break;
      case "modified-time-descending":
        sortIcon = "pencil";
        buttonEl.setAttribute("aria-label", "Sort by modification date (most recent first)");
        buttonEl.title = "Current sort: By modification date (most recent first)\nClick to change sort method";
        break;
      case "modified-time-ascending":
        sortIcon = "pencil-line";
        buttonEl.setAttribute("aria-label", "Sort by modification date (oldest first)");
        buttonEl.title = "Current sort: By modification date (oldest first)\nClick to change sort method";
        break;
    }
    const iconSpan = buttonEl.createSpan();
    (0, import_obsidian8.setIcon)(iconSpan, sortIcon);
  }
  /**
   * Show the sort menu at the given button
   */
  showSortMenu(sortBtn, onSortChange) {
    const menu = new import_obsidian8.Menu();
    menu.addItem((item) => {
      item.setTitle("Sort alphabetically").setIcon(this.sortMode === "alphabetically-descending" ? "checkmark" : "").onClick(() => {
        this.sortMode = "alphabetically-descending";
        onSortChange(this.sortMode);
      });
    });
    menu.addItem((item) => {
      item.setTitle("Sort by note count").setIcon(this.sortMode === "file-count-descending" ? "checkmark" : "").onClick(() => {
        this.sortMode = "file-count-descending";
        onSortChange(this.sortMode);
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Sort by creation date (newest first)").setIcon(this.sortMode === "created-time-descending" ? "checkmark" : "").onClick(() => {
        this.sortMode = "created-time-descending";
        onSortChange(this.sortMode);
      });
    });
    menu.addItem((item) => {
      item.setTitle("Sort by creation date (oldest first)").setIcon(this.sortMode === "created-time-ascending" ? "checkmark" : "").onClick(() => {
        this.sortMode = "created-time-ascending";
        onSortChange(this.sortMode);
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Sort by modification date (newest first)").setIcon(this.sortMode === "modified-time-descending" ? "checkmark" : "").onClick(() => {
        this.sortMode = "modified-time-descending";
        onSortChange(this.sortMode);
      });
    });
    menu.addItem((item) => {
      item.setTitle("Sort by modification date (oldest first)").setIcon(this.sortMode === "modified-time-ascending" ? "checkmark" : "").onClick(() => {
        this.sortMode = "modified-time-ascending";
        onSortChange(this.sortMode);
      });
    });
    const rect = sortBtn.getBoundingClientRect();
    menu.showAtPosition({ x: rect.left, y: rect.bottom });
  }
  /**
   * Render the expand button with current state
   */
  renderExpandButton(buttonEl) {
    if (this.expandAll) {
      (0, import_obsidian8.setIcon)(buttonEl, "chevrons-down-up");
      buttonEl.setAttribute("aria-label", "Collapse all tags");
      buttonEl.title = "Currently showing expanded tags\nClick to collapse all tag groups";
    } else {
      (0, import_obsidian8.setIcon)(buttonEl, "chevrons-up-down");
      buttonEl.setAttribute("aria-label", "Expand all tags");
      buttonEl.title = "Currently showing collapsed tags\nClick to expand all tag groups";
    }
  }
  /**
   * Create a filter input with a clear button
   */
  createFilterInput(container, initialValue, placeholder, onChange) {
    const filterWrapper = container.createEl("div", { cls: "filter-input-container" });
    const filterInput = filterWrapper.createEl("input", {
      type: "search",
      placeholder,
      cls: "filter-input"
    });
    filterInput.value = initialValue;
    const clearButton = filterWrapper.createEl("span", {
      cls: "search-input-clear-button",
      attr: {
        "aria-label": "Clear filter"
      }
    });
    clearButton.style.display = initialValue ? "flex" : "none";
    filterInput.oninput = () => {
      const value = filterInput.value.trim();
      clearButton.style.display = value ? "flex" : "none";
      onChange(value);
    };
    clearButton.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      filterInput.value = "";
      clearButton.style.display = "none";
      onChange("");
      filterInput.focus();
    };
    return filterInput;
  }
  /**
   * Build a hierarchical structure of tags and their associated notes.
   */
  buildTagHierarchy() {
    const hierarchy = {};
    const allFiles = this.plugin.app.vault.getMarkdownFiles();
    for (const file of allFiles) {
      const fileCache = this.plugin.app.metadataCache.getFileCache(file);
      if (fileCache) {
        const tags = gatherTagsFromCache(fileCache);
        if (tags.size === 0) {
          if (!hierarchy["untagged"]) {
            hierarchy["untagged"] = { files: /* @__PURE__ */ new Set(), children: {} };
          }
          hierarchy["untagged"].files.add(file);
        } else {
          for (const tag of tags) {
            this.addToHierarchy(hierarchy, tag.split("/"), file);
          }
        }
      } else {
        if (!hierarchy["untagged"]) {
          hierarchy["untagged"] = { files: /* @__PURE__ */ new Set(), children: {} };
        }
        hierarchy["untagged"].files.add(file);
      }
    }
    return hierarchy;
  }
  /**
   * Helper method to add a file to the hierarchy at the given path
   */
  addToHierarchy(hierarchy, segments, file) {
    const [head, ...rest] = segments;
    if (!hierarchy[head]) {
      hierarchy[head] = { files: /* @__PURE__ */ new Set(), children: {} };
    }
    if (rest.length === 0) {
      hierarchy[head].files.add(file);
    } else {
      this.addToHierarchy(hierarchy[head].children, rest, file);
    }
  }
  /**
   * Recursively filter the hierarchy so only nodes/files that match `filterQuery` remain.
   */
  filterHierarchy(hierarchy, filterQuery, isAncestorMatched = false) {
    if (!filterQuery) {
      return hierarchy;
    }
    const result = {};
    const normalizedFilterQuery = filterQuery.toLowerCase();
    for (const [key, { files, children }] of Object.entries(hierarchy)) {
      const actualTagNameMatchesQuery = key.toLowerCase().includes(normalizedFilterQuery);
      const newIsAncestorMatched = isAncestorMatched || actualTagNameMatchesQuery;
      const filteredChildren = this.filterHierarchy(children, filterQuery, newIsAncestorMatched);
      const matchingFiles = new Set(
        [...files].filter(
          (file) => file.basename.toLowerCase().includes(normalizedFilterQuery)
        )
      );
      let includeNode = false;
      let filesToShow = /* @__PURE__ */ new Set();
      switch (this.filterMode) {
        case "tags-and-files" /* TagsAndFiles */:
          if (actualTagNameMatchesQuery || isAncestorMatched || matchingFiles.size > 0 || Object.keys(filteredChildren).length > 0) {
            includeNode = true;
            if (actualTagNameMatchesQuery || isAncestorMatched) {
              filesToShow = /* @__PURE__ */ new Set([...files]);
            } else {
              filesToShow = matchingFiles;
            }
          }
          break;
        case "tags-only" /* TagsOnly */:
          if (actualTagNameMatchesQuery || isAncestorMatched || Object.keys(filteredChildren).length > 0) {
            includeNode = true;
            filesToShow = /* @__PURE__ */ new Set([...files]);
          }
          break;
        case "files-only" /* FilesOnly */:
          if (matchingFiles.size > 0 || Object.keys(filteredChildren).length > 0) {
            includeNode = true;
            filesToShow = matchingFiles;
          } else if ((actualTagNameMatchesQuery || isAncestorMatched) && Object.keys(filteredChildren).length === 0 && matchingFiles.size === 0) {
            includeNode = true;
            filesToShow = /* @__PURE__ */ new Set();
          }
          break;
      }
      if (includeNode) {
        result[key] = {
          files: filesToShow,
          children: filteredChildren
        };
      }
    }
    return result;
  }
  /**
   * Sort the hierarchy using the current sort mode
   */
  sortHierarchy(hierarchy, mode) {
    const sortedEntries = Object.entries(hierarchy).map(([key, node]) => {
      return [
        key,
        {
          files: node.files,
          children: this.sortHierarchy(node.children, mode)
        }
      ];
    });
    switch (mode) {
      case "alphabetically-descending":
        sortedEntries.sort(
          (a, b) => a[0].localeCompare(b[0], void 0, { sensitivity: "base" })
        );
        break;
      case "file-count-descending":
        sortedEntries.sort((a, b) => {
          const countA = this.getTotalFileCountForNode(a[1]);
          const countB = this.getTotalFileCountForNode(b[1]);
          if (countB === countA) {
            return a[0].localeCompare(b[0], void 0, { sensitivity: "base" });
          }
          return countB - countA;
        });
        break;
      case "created-time-descending":
      case "created-time-ascending":
        sortedEntries.sort((a, b) => {
          const filesA = Array.from(a[1].files);
          const filesB = Array.from(b[1].files);
          if (filesA.length === 0 && filesB.length === 0) {
            return a[0].localeCompare(b[0], void 0, { sensitivity: "base" });
          }
          const getNewestCtime = (files) => {
            if (files.length === 0)
              return 0;
            return mode === "created-time-descending" ? Math.max(...files.map((f) => f.stat.ctime)) : Math.min(...files.map((f) => f.stat.ctime));
          };
          const ctimeA = getNewestCtime(filesA);
          const ctimeB = getNewestCtime(filesB);
          if (ctimeA === ctimeB) {
            return a[0].localeCompare(b[0], void 0, { sensitivity: "base" });
          }
          return mode === "created-time-descending" ? ctimeB - ctimeA : ctimeA - ctimeB;
        });
        break;
      case "modified-time-descending":
      case "modified-time-ascending":
        sortedEntries.sort((a, b) => {
          const filesA = Array.from(a[1].files);
          const filesB = Array.from(b[1].files);
          if (filesA.length === 0 && filesB.length === 0) {
            return a[0].localeCompare(b[0], void 0, { sensitivity: "base" });
          }
          const getNewestMtime = (files) => {
            if (files.length === 0)
              return 0;
            return mode === "modified-time-descending" ? Math.max(...files.map((f) => f.stat.mtime)) : Math.min(...files.map((f) => f.stat.mtime));
          };
          const mtimeA = getNewestMtime(filesA);
          const mtimeB = getNewestMtime(filesB);
          if (mtimeA === mtimeB) {
            return a[0].localeCompare(b[0], void 0, { sensitivity: "base" });
          }
          return mode === "modified-time-descending" ? mtimeB - mtimeA : mtimeA - mtimeB;
        });
        break;
    }
    const result = {};
    for (const [k, v] of sortedEntries) {
      result[k] = v;
    }
    return result;
  }
  /**
   * Render the tag hierarchy recursively.
   */
  renderTagGroup(container, group, path = [], openFileCallback, previouslyExpandedPaths) {
    for (const [key, { files, children }] of Object.entries(group)) {
      const shouldCollapse = Object.keys(children).length === 1 && files.size === 0;
      if (shouldCollapse) {
        const [nextKey, nextValue] = Object.entries(children)[0];
        this.renderTagGroup(container, { [`${key}/${nextKey}`]: nextValue }, path, openFileCallback, previouslyExpandedPaths);
        continue;
      }
      const currentTagPath = (path.length > 0 ? path.join("/") + "/" : "") + key;
      const groupContainer = container.createEl("details", { cls: "tag-group" });
      groupContainer.setAttribute("data-tag-path", currentTagPath);
      if (this.expandAll || previouslyExpandedPaths && previouslyExpandedPaths.has(currentTagPath)) {
        groupContainer.setAttribute("open", "true");
      }
      const groupHeader = groupContainer.createEl("summary", { cls: "tag-group-header" });
      const icon = groupHeader.createEl("span", { cls: "tag-group-icon" });
      (0, import_obsidian8.setIcon)(icon, groupContainer.open ? this.plugin.settings.nbtTagGroupOpenIcon : this.plugin.settings.nbtTagGroupClosedIcon);
      groupContainer.addEventListener("toggle", () => {
        (0, import_obsidian8.setIcon)(icon, groupContainer.open ? this.plugin.settings.nbtTagGroupOpenIcon : this.plugin.settings.nbtTagGroupClosedIcon);
      });
      const tagName = groupHeader.createEl("span", { cls: "tag-group-name" });
      if (this.filterMode === "files-only" /* FilesOnly */) {
        tagName.textContent = key;
      } else {
        tagName.innerHTML = this.highlightMatches(key, this.filterQuery);
      }
      tagName.title = path.length !== 0 ? `${path}/${key}` : key;
      const totalCount = this.getTotalFileCountForNode({ files, children });
      if (totalCount > 0) {
        const count = groupHeader.createEl("span", {
          cls: "tag-group-count"
        });
        count.innerText = `${totalCount}`;
        const directFileCount = files.size;
        const childFileCount = totalCount - directFileCount;
        let tooltipText = `Total notes: ${totalCount}`;
        if (directFileCount > 0) {
          tooltipText += `
Direct tag matches: ${directFileCount}`;
        }
        if (childFileCount > 0) {
          tooltipText += `
Notes in subtags: ${childFileCount}`;
        }
        count.title = tooltipText;
      }
      this.renderTagGroup(groupContainer, children, [...path, key], openFileCallback, previouslyExpandedPaths);
      let sortedFiles = Array.from(files);
      switch (this.sortMode) {
        case "alphabetically-descending":
          sortedFiles.sort(
            (a, b) => a.basename.localeCompare(b.basename, void 0, { sensitivity: "base" })
          );
          break;
        case "created-time-descending":
          sortedFiles.sort((a, b) => b.stat.ctime - a.stat.ctime);
          break;
        case "created-time-ascending":
          sortedFiles.sort((a, b) => a.stat.ctime - b.stat.ctime);
          break;
        case "modified-time-descending":
          sortedFiles.sort((a, b) => b.stat.mtime - a.stat.mtime);
          break;
        case "modified-time-ascending":
          sortedFiles.sort((a, b) => a.stat.mtime - b.stat.mtime);
          break;
      }
      const list = groupContainer.createEl("ul", { cls: "tag-group-list" });
      for (const file of sortedFiles) {
        const listItem = list.createEl("li", { cls: "tag-group-note" });
        listItem.title = file.path;
        const link = listItem.createEl("a", {
          cls: "internal-link",
          href: `#${file.path}`
        });
        if (this.plugin.settings.nbtFileIcon) {
          (0, import_obsidian8.setIcon)(link, this.plugin.settings.nbtFileIcon);
        } else {
          link.style.marginLeft = "-1.25rem";
        }
        const nameSpan = link.createEl("span");
        if (this.filterMode === "tags-only" /* TagsOnly */) {
          nameSpan.textContent = file.basename;
        } else {
          nameSpan.innerHTML = this.highlightMatches(file.basename, this.filterQuery);
        }
        if (this.sortMode.includes("time")) {
          const timeSpan = link.createEl("span", { cls: "tag-note-time" });
          const date = this.sortMode.includes("created") ? new Date(file.stat.ctime) : new Date(file.stat.mtime);
          timeSpan.innerText = date.toLocaleDateString();
          const dateType = this.sortMode.includes("created") ? "Created" : "Modified";
          timeSpan.title = `${dateType}: ${date.toLocaleString()}`;
        }
        link.onclick = (evt) => {
          evt.preventDefault();
          openFileCallback(file);
        };
        listItem.addEventListener("contextmenu", (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          const menu = new import_obsidian8.Menu();
          this.plugin.app.workspace.trigger("file-menu", menu, file, this.plugin.app.workspace.getLeaf());
          menu.showAtMouseEvent(evt);
        });
      }
    }
  }
  /**
   * Returns the total number of files for a given node (including children).
   */
  getTotalFileCountForNode(nodeData) {
    let count = nodeData.files.size;
    for (const child of Object.values(nodeData.children)) {
      count += this.getTotalFileCountForNode(child);
    }
    return count;
  }
  /**
   * Helper method to highlight all occurrences of `filter` within `original`,
   * wrapping them in <span class="highlight">... </span>. (Case-insensitive)
   */
  highlightMatches(original, filter) {
    if (!filter)
      return original;
    const escaped = filter.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const regex = new RegExp(`(${escaped})`, "gi");
    return original.replace(regex, `<span class="highlight">$1</span>`);
  }
  /**
   * Render the settings button.
   */
  renderSettingsButton(buttonEl) {
    buttonEl.empty();
    (0, import_obsidian8.setIcon)(buttonEl, "settings");
    buttonEl.setAttribute("aria-label", "View settings");
    buttonEl.title = "View settings (e.g., filter mode)";
  }
  /**
   * Show the settings menu at the given button.
   * Currently, this menu only contains filter mode options.
   */
  showSettingsMenu(settingsBtn, onFilterModeChange, onRefresh) {
    const menu = new import_obsidian8.Menu();
    menu.addItem((item) => item.setTitle("Filter Scope").setDisabled(true));
    menu.addItem((item) => {
      item.setTitle("Tags & Filenames").setIcon(this.filterMode === "tags-and-files" /* TagsAndFiles */ ? "checkmark" : "").onClick(() => {
        this.setFilterMode("tags-and-files" /* TagsAndFiles */);
        onFilterModeChange(this.getFilterMode());
      });
    });
    menu.addItem((item) => {
      item.setTitle("Tags Only").setIcon(this.filterMode === "tags-only" /* TagsOnly */ ? "checkmark" : "").onClick(() => {
        this.setFilterMode("tags-only" /* TagsOnly */);
        onFilterModeChange(this.getFilterMode());
      });
    });
    menu.addItem((item) => {
      item.setTitle("Filenames Only").setIcon(this.filterMode === "files-only" /* FilesOnly */ ? "checkmark" : "").onClick(() => {
        this.setFilterMode("files-only" /* FilesOnly */);
        onFilterModeChange(this.getFilterMode());
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("Refresh").onClick(() => onRefresh());
    });
    const rect = settingsBtn.getBoundingClientRect();
    menu.showAtPosition({ x: rect.left, y: rect.bottom });
  }
  /**
   * Gathers the paths of all currently expanded tag groups.
   * @param containerEl The HTML element containing the tag groups.
   * @returns A Set of strings, where each string is the data-tag-path of an expanded group.
   */
  getCurrentlyExpandedTagPaths(containerEl) {
    const expandedPaths = /* @__PURE__ */ new Set();
    const openGroups = containerEl.querySelectorAll("details.tag-group[open]");
    openGroups.forEach((group) => {
      const path = group.getAttribute("data-tag-path");
      if (path) {
        expandedPaths.add(path);
      }
    });
    return expandedPaths;
  }
};

// src/navByTag/NavByTagView.ts
var TAG_NAVIGATION_VIEW_TYPE = "tag-navigation-view";
var NavByTagView = class extends import_obsidian9.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.listContainerEl = null;
    this.filterQuery = "";
    this.plugin = plugin;
    this.renderer = new TagNavigationRenderer(plugin, plugin.settings.nbtDefaultSort);
  }
  getViewType() {
    return TAG_NAVIGATION_VIEW_TYPE;
  }
  getDisplayText() {
    return "Tag Navigation";
  }
  getIcon() {
    return "folder-tree";
  }
  refresh() {
    this.renderList();
  }
  async onOpen() {
    this.buildView();
  }
  async onClose() {
  }
  /**
   * Build the view container including controls and list area
   */
  buildView() {
    const container = this.containerEl;
    container.empty();
    container.addClass("tag-navigation-container");
    const header = container.createEl("div", { cls: "tag-navigation-header" });
    const titleRow = header.createEl("div", { cls: "tag-navigation-title-row" });
    titleRow.createEl("h4", { text: "Tag Navigation" });
    const controls = titleRow.createEl("div", { cls: "tag-navigation-controls" });
    const sortBtn = controls.createEl("button", { cls: "tag-nav-sort-btn clickable-icon" });
    this.renderer.renderSortButton(sortBtn);
    sortBtn.setAttribute("aria-label", "Sort options");
    sortBtn.title = "Click to open sort options";
    sortBtn.onclick = (event) => {
      this.renderer.showSortMenu(sortBtn, (newMode) => {
        this.renderer.renderSortButton(sortBtn);
        this.renderList();
      });
      event.preventDefault();
      event.stopPropagation();
    };
    const expandAllBtn = controls.createEl("button", { cls: "tag-nav-expand-btn clickable-icon" });
    this.renderer.renderExpandButton(expandAllBtn);
    expandAllBtn.onclick = () => {
      const wasPreviouslyExpandingAll = this.renderer.getExpandAll();
      this.renderer.setExpandAll(!wasPreviouslyExpandingAll);
      this.renderer.renderExpandButton(expandAllBtn);
      if (!this.renderer.getExpandAll()) {
        this.renderList(true);
      } else {
        this.renderList(false);
      }
    };
    const settingsBtn = controls.createEl("button", { cls: "tag-nav-settings-btn clickable-icon" });
    this.renderer.renderSettingsButton(settingsBtn);
    settingsBtn.onclick = (event) => {
      this.renderer.showSettingsMenu(
        settingsBtn,
        (newFilterMode) => {
          this.renderer.renderSettingsButton(settingsBtn);
          this.renderList();
        },
        () => this.refresh()
      );
      event.preventDefault();
      event.stopPropagation();
    };
    this.renderer.createFilterInput(
      header,
      this.filterQuery,
      "Filter tags...",
      (value) => {
        this.filterQuery = value.toLowerCase();
        this.renderer.setFilterQuery(this.filterQuery);
        this.renderList();
      }
    );
    this.listContainerEl = container.createEl("div", { cls: "tag-navigation-list-container" });
    this.renderList();
  }
  /**
   * Render the tag hierarchy list
   */
  renderList(isCollapseAllAction = false) {
    if (!this.listContainerEl)
      return;
    let previouslyExpandedPaths;
    if (isCollapseAllAction) {
      previouslyExpandedPaths = /* @__PURE__ */ new Set();
    } else {
      previouslyExpandedPaths = this.renderer.getCurrentlyExpandedTagPaths(this.listContainerEl);
    }
    this.listContainerEl.empty();
    const tagHierarchy = this.renderer.buildTagHierarchy();
    const filteredHierarchy = this.renderer.filterHierarchy(tagHierarchy, this.renderer.getFilterQuery());
    const sortedHierarchy = this.renderer.sortHierarchy(filteredHierarchy, this.renderer.getSortMode());
    this.renderer.renderTagGroup(this.listContainerEl, sortedHierarchy, [], (file) => {
      this.app.workspace.getLeaf().openFile(file);
    }, previouslyExpandedPaths);
  }
};

// main.ts
var TagTacticianPlugin = class extends import_obsidian10.Plugin {
  constructor() {
    super(...arguments);
    this.activeFilePath = null;
  }
  async onload() {
    await this.loadSettings();
    this.setupBatchTagEditing();
    this.setupRelatedNotesView();
    this.setupNavByTag();
    this.addSettingTab(new TagTacticianSettingTab(this.app, this));
  }
  /**
   * Clean up when plugin is disabled
   */
  onunload() {
    this.app.workspace.detachLeavesOfType(RELATED_NOTES_VIEW_TYPE);
    this.app.workspace.detachLeavesOfType(TAG_NAVIGATION_VIEW_TYPE);
  }
  // --------------------------------
  // Settings
  // --------------------------------
  /**
   * Load plugin settings
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Save plugin settings
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // --------------------------------
  // Batch Tag Editing
  // --------------------------------
  /**
   * Set up batch tag editing feature
   */
  setupBatchTagEditing() {
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (!file)
          return;
        this.addTagMenuItem(menu, [file]);
      })
    );
    this.registerEvent(
      this.app.workspace.on("files-menu", (menu, files) => {
        if (!files || files.length === 0)
          return;
        this.addTagMenuItem(menu, files);
      })
    );
    this.registerEvent(
      this.app.workspace.on("search:results-menu", (menu, leaf) => {
        let files = [];
        leaf.dom.vChildren.children.forEach((e) => files.push(e.file));
        if (files.length < 1) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("Tag-Tactician: Edit tags on " + files.length + " notes...").setIcon("tag").onClick(() => {
            new EditTagsModal(this.app, files, async (updates) => {
              const modifiedCount = await applyTagUpdates(
                this.app,
                updates,
                this.settings
              );
              new import_obsidian10.Notice(`Updated frontmatter tags in ${modifiedCount} file(s).`);
            }).open();
          });
        });
      })
    );
  }
  /**
   * Add tag editing menu item to the context menu
   */
  addTagMenuItem(menu, selection) {
    menu.addItem((item) => {
      item.setTitle("Edit tags (frontmatter)").setIcon("hashtag").onClick(async () => {
        const allItems = expandFolders(selection);
        new EditTagsModal(this.app, allItems, async (updates) => {
          const modifiedCount = await applyTagUpdates(
            this.app,
            updates,
            this.settings
          );
          new import_obsidian10.Notice(`Updated frontmatter tags in ${modifiedCount} file(s).`);
        }).open();
      });
    });
  }
  // --------------------------------
  // Related Notes
  // --------------------------------
  /**
   * Set up the Related Notes view
   */
  setupRelatedNotesView() {
    this.tagIndexer = new TagIndexer(this);
    this.registerView(RELATED_NOTES_VIEW_TYPE, (leaf) => new RelatedNotesView(leaf, this));
    this.registerEvent(
      this.app.workspace.on("layout-ready", async () => {
        await this.activateRelatedNotesView();
      })
    );
    this.addCommand({
      id: "open-related-notes-view",
      name: "Open Related Notes Sidebar",
      callback: () => this.activateRelatedNotesView()
    });
    let timer = null;
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        window.clearTimeout(timer);
        timer = window.setTimeout(() => {
          var _a;
          const mdView = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
          if (!mdView)
            return;
          const file = mdView.file;
          this.activeFilePath = (_a = file == null ? void 0 : file.path) != null ? _a : null;
          this.updateRelatedNotesView();
        }, 150);
      })
    );
    this.registerHoverLinkSource(
      RELATED_NOTES_VIEW_TYPE,
      {
        display: "Related Notes",
        defaultMod: true
      }
    );
    this.app.workspace.onLayoutReady(async () => {
      await this.tagIndexer.buildIndex();
      console.log(`[Tag Tactician] Related notes index built after layout ready.`);
    });
  }
  /**
   * Update the Related Notes view
   */
  updateRelatedNotesView() {
    const leaves = this.app.workspace.getLeavesOfType(RELATED_NOTES_VIEW_TYPE);
    if (!leaves.length)
      return;
    const leaf = leaves[0];
    const view = leaf.view instanceof RelatedNotesView ? leaf.view : null;
    if (view)
      view.refresh();
  }
  /**
   * Activate the Related Notes view
   */
  async activateRelatedNotesView() {
    const leaves = this.app.workspace.getLeavesOfType(RELATED_NOTES_VIEW_TYPE);
    let leaf = leaves.length > 0 ? leaves[0] : null;
    if (!leaf) {
      const rightLeaf = this.app.workspace.getRightLeaf(false);
      if (rightLeaf) {
        await rightLeaf.setViewState({ type: RELATED_NOTES_VIEW_TYPE });
        this.app.workspace.revealLeaf(rightLeaf);
      }
    } else {
      this.app.workspace.revealLeaf(leaf);
    }
    this.updateRelatedNotesView();
  }
  /**
   * Compute notes related to the active note
   * We re-scan the current note's tags, then ask `tagIndexer` to rank.
   */
  computeRelatedNotes() {
    if (!this.activeFilePath)
      return [];
    return this.tagIndexer.computeRelatedNotes(this.activeFilePath);
  }
  // --------------------------------
  // Nav By Tag
  // --------------------------------
  /**
   * Set up the Tag Navigation view
   */
  setupNavByTag() {
    this.registerView(
      TAG_NAVIGATION_VIEW_TYPE,
      (leaf) => new NavByTagView(leaf, this)
    );
    this.registerEvent(
      this.app.workspace.on("layout-ready", async () => {
        await this.activateTagNavigationView();
      })
    );
    this.addCommand({
      id: "open-tag-navigation-view",
      name: "Open Tag-Based File Navigation",
      callback: () => this.activateTagNavigationView()
    });
    let timer = null;
    this.registerEvent(
      this.app.metadataCache.on("changed", (file, meta) => {
        window.clearTimeout(timer);
        timer = window.setTimeout(() => this.refreshTagNavigationView(), 150);
      })
    );
  }
  /**
   * Activate the Tag Navigation view
   */
  async activateTagNavigationView() {
    const leaves = this.app.workspace.getLeavesOfType(TAG_NAVIGATION_VIEW_TYPE);
    let leaf = leaves.length > 0 ? leaves[0] : null;
    if (!leaf) {
      const leftLeaf = this.app.workspace.getLeftLeaf(false);
      if (leftLeaf) {
        await leftLeaf.setViewState({ type: TAG_NAVIGATION_VIEW_TYPE });
        await this.app.workspace.revealLeaf(leftLeaf);
      }
    } else {
      await this.app.workspace.revealLeaf(leaf);
    }
  }
  refreshTagNavigationView() {
    const leaves = this.app.workspace.getLeavesOfType(TAG_NAVIGATION_VIEW_TYPE);
    let leaf = leaves.length > 0 ? leaves[0] : null;
    const view = leaf.view instanceof NavByTagView ? leaf.view : null;
    if (view)
      view.refresh();
  }
};
function expandFolders(selection) {
  const results = [];
  for (const item of selection) {
    if (item instanceof import_obsidian10.TFolder) {
      import_obsidian10.Vault.recurseChildren(item, (child) => {
        if (child instanceof import_obsidian10.TFile) {
          results.push(child);
        }
      });
    } else {
      results.push(item);
    }
  }
  return results;
}
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/


/* nosourcemap */